# 1. 라이브러리 로드
import cv2, time, numpy as np, serial, json, os
from ultralytics import YOLO

# 2. 아두이노와 시리얼 통신 설정
try:
    arduino = serial.Serial("/dev/ttyUSB0", 9600, timeout=1)
    time.sleep(2)
    print("디버깅: 아두이노와 시리얼 통신 연결 성공.")
except Exception as e:
    print(f"디버깅 오류: 아두이노와 연결할 수 없습니다: {e}")
    exit()

# 3. 설정 파일 로드 및 파라미터 정의
CONFIG_FILE = "tuning_config.json"
config = {}
if os.path.exists(CONFIG_FILE):
    print(f"설정 파일 '{CONFIG_FILE}'을 발견했습니다. 튜닝 값을 로드합니다.")
    with open(CONFIG_FILE, "r") as f:
        config = json.load(f)
else:
    print(f"설정 파일 '{CONFIG_FILE}'이 없습니다. 코드에 지정된 기본값을 사용합니다.")

# 차선 탐지 파라미터
ROI_START_Y_RATIO = config.get('roi_start_y_ratio', 0.34)
v_low = config.get('v_low', 222)
LANE_FILTER_HSV = {"s_low": 0, "s_high": 63, "v_low": v_low}
SLOPE_MIN = config.get('slope_min', 0.3)
SLOPE_MAX = config.get('slope_max', 2.5)
CENTER_OFFSET = config.get('center_offset', 81)
CANNY_LOW, CANNY_HIGH = 51, 150
HOUGH_THRESH, HOUGH_MIN_LEN, HOUGH_MAX_GAP = 40, 35, 85

# 4. 카메라 및 YOLO 모델 설정
model = YOLO("yolov8n.pt")
cap = cv2.VideoCapture(0)

if not cap.isOpened():
    print("디버깅 오류: 웹캠을 열 수 없습니다.")
    exit()

width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
print(f"디버깅: 웹캠 해상도: {width}x{height}")

# 5. 원근 변환 설정
src_pts = np.float32(config.get('src_pts', [[214, 99], [379, 109], [590, 473], [-25, 467]]))
road_width_m = config.get('road_width_m', 0.18)
road_length_m = config.get('road_length_m', 0.51)
dst_pts = np.float32([[0, 0], [road_width_m, 0], [road_width_m, road_length_m], [0, road_length_m]])
M = cv2.getPerspectiveTransform(src_pts, dst_pts)
print("디버깅: 원근 변환 행렬 생성 완료.")

# 6. 주행 로직 및 상태 관련 설정
TARGET_SPEED_MS = 0.8
TTC_THRESHOLD_S = 3.5
LANE_TARGET_OFFSET_RATIO = 0.1
EVASION_DURATION_STEP1 = 1.0
EVASION_DURATION_STEP2 = 2.0
EVASION_DURATION_STEP3 = 1.0

LANE_KEEPING, EVASION = 'LANE_KEEPING', 'EVASION'
EVASION_STEP_1, EVASION_STEP_2, EVASION_STEP_3 = 1, 2, 3
driving_mode, evasion_step, evasion_timer = LANE_KEEPING, 0, 0

LANE_KEEP_L_ANGLE, LANE_KEEP_R_ANGLE = 105, 78
STOP_L_ANGLE, STOP_R_ANGLE = 90, 90

# 7. 함수 정의
def drive_angles(left_angle, right_angle):
    command = f"M,{int(left_angle)},{int(right_angle)}\n"
    arduino.write(command.encode())

def get_bottom_x(line, roi_height):
    x1, y1, x2, y2 = line[0]
    if y1 == y2: return (x1 + x2) / 2
    m = (x2 - x1) / (y2 - y1)
    b = x1 - m * y1
    y = roi_height - 1
    x = m * y + b
    return int(x)

def process_lanes_improved(img):
    roi_start_y = int(img.shape[0] * ROI_START_Y_RATIO)
    roi_frame = img[roi_start_y:, :]
    roi_width = roi_frame.shape[1]
    
    hsv = cv2.cvtColor(roi_frame, cv2.COLOR_BGR2HSV)
    lower_white = np.array([0, LANE_FILTER_HSV['s_low'], LANE_FILTER_HSV['v_low']])
    upper_white = np.array([180, LANE_FILTER_HSV['s_high'], 255])
    white_mask = cv2.inRange(hsv, lower_white, upper_white)
    edges = cv2.Canny(white_mask, CANNY_LOW, CANNY_HIGH)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, HOUGH_THRESH, minLineLength=HOUGH_MIN_LEN, maxLineGap=HOUGH_MAX_GAP)
    
    left_lines, right_lines = [], []
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0]
            if x2 == x1: continue
            slope = (y2 - y1) / (x2 - x1)
            if SLOPE_MIN < abs(slope) < SLOPE_MAX:
                if slope < 0 and x2 < roi_width / 2 + CENTER_OFFSET:
                    left_lines.append(line)
                elif slope > 0 and x1 > roi_width / 2 - CENTER_OFFSET:
                    right_lines.append(line)

    best_left_line, best_right_line = None, None
    if left_lines:
        best_left_line = max(left_lines, key=lambda line: get_bottom_x(line, roi_frame.shape[0]))
    if right_lines:
        best_right_line = min(right_lines, key=lambda line: get_bottom_x(line, roi_frame.shape[0]))
        
    return best_left_line, best_right_line, roi_frame

# 8. 메인 루프
jetson_control_active = False # 자동/수동 제어 변수
print("="*40 + "\n초기 상태: [MANUAL CONTROL]\n스페이스바를 눌러 [AUTO CONTROL] 모드로 전환하세요.\n" + "="*40)

try:
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret: break
        
        results = model.track(frame, persist=True, imgsz=320, conf=0.5, tracker="bytetrack.yaml", verbose=False)[0]
        min_ttc = float('inf')
        if results.boxes.id is not None:
            # (객체 처리 코드)
            pass

        closest_left, closest_right, roi_frame_for_lane = process_lanes_improved(frame)
        lane_dev = 0.0
        
        #  한쪽 차선 인식 로직
        if closest_left is not None and closest_right is not None:
            left_x = get_bottom_x(closest_left, roi_frame_for_lane.shape[0])
            right_x = get_bottom_x(closest_right, roi_frame_for_lane.shape[0])
            lane_center_x = (left_x + right_x) / 2
            lane_dev = (lane_center_x - roi_frame_for_lane.shape[1] / 2) / (roi_frame_for_lane.shape[1] / 2)
        elif closest_left is not None:
            left_x = get_bottom_x(closest_left, roi_frame_for_lane.shape[0])
            target_x = roi_frame_for_lane.shape[1] * (0.5 - LANE_TARGET_OFFSET_RATIO)
            lane_dev = (left_x - target_x) / (roi_frame_for_lane.shape[1] / 2)
        elif closest_right is not None:
            right_x = get_bottom_x(closest_right, roi_frame_for_lane.shape[0])
            target_x = roi_frame_for_lane.shape[1] * (0.5 + LANE_TARGET_OFFSET_RATIO)
            lane_dev = (right_x - target_x) / (roi_frame_for_lane.shape[1] / 2)

        # 자동/수동 제어(jetson_control_active) 로직
        if jetson_control_active:
            if driving_mode == LANE_KEEPING:
                if min_ttc < TTC_THRESHOLD_S:
                    driving_mode = EVASION; evasion_step = EVASION_STEP_1; evasion_timer = time.time()
                    print(f"[!!!] TTC {min_ttc:.2f}초! [장애물 회피 모드]로 전환")
                else:
                    final_l_angle, final_r_angle = LANE_KEEP_L_ANGLE, LANE_KEEP_R_ANGLE
                    if abs(lane_dev) > 0.15:
                        # 조향 민감도는 admotor11.py의 '25'를 따름
                        correction_angle = int(lane_dev * 25)
                        final_l_angle += correction_angle
                        final_r_angle += correction_angle
                    drive_angles(final_l_angle, final_r_angle)
            
            # 장애물 회피 로직
            elif driving_mode == EVASION:
                if evasion_step == EVASION_STEP_1:
                    drive_angles(110, 80)
                    if time.time() - evasion_timer > EVASION_DURATION_STEP1:
                        evasion_step = EVASION_STEP_2; evasion_timer = time.time()
                elif evasion_step == EVASION_STEP_2:
                    drive_angles(105, 75)
                    if time.time() - evasion_timer > EVASION_DURATION_STEP2:
                        evasion_step = EVASION_STEP_3; evasion_timer = time.time()
                elif evasion_step == EVASION_STEP_3:
                    drive_angles(100, 80)
                    if time.time() - evasion_timer > EVASION_DURATION_STEP3:
                        driving_mode = LANE_KEEPING; print("[상태] 회피 완료.")
        
        disp = frame.copy()
        significant_lanes = [l for l in [closest_left, closest_right] if l is not None]
        if significant_lanes:
            roi_start_y = int(height * ROI_START_Y_RATIO)
            for line in significant_lanes:
                x1, y1, x2, y2 = line[0]
                cv2.line(disp, (x1, y1 + roi_start_y), (x2, y2 + roi_start_y), (0, 0, 255), 4)
        
        control_mode_text = "AUTO" if jetson_control_active else "MANUAL"
        control_color = (0, 255, 0) if jetson_control_active else (0, 165, 255)
        action_state = driving_mode if jetson_control_active else "N/A"
        if jetson_control_active and driving_mode == EVASION: action_state = f"EVASION_{evasion_step}"
        status_text = f"Mode:{control_mode_text} | L_Dev:{lane_dev:.2f} | Action:{action_state}"
        cv2.putText(disp, status_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, control_color, 2)
        cv2.imshow("Final Autonomous Drive", disp)
        
        # 스페이스바를 이용한 수동/자동 전환 로직
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q') or key == 27: break
        elif key == 32:
            jetson_control_active = not jetson_control_active
            if jetson_control_active: print("\n[AUTO CONTROL] 모드 활성화")
            else: print("\n[MANUAL CONTROL] 모드 활성화"); drive_angles(STOP_L_ANGLE, STOP_R_ANGLE)

finally:
    print("프로그램 종료. 마지막으로 모터를 정지합니다.")
    drive_angles(STOP_L_ANGLE, STOP_R_ANGLE)
    cap.release()
    cv2.destroyAllWindows()
    arduino.close()
    print("모든 자원 해제 완료.")

